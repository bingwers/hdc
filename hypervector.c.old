

#ifndef HYPERVECTOR_C
#define HYPERVECTOR_C

#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct Hypervector_Basis Hypervector_Basis;
typedef struct Hypervector_Hypervector Hypervector_Hypervector;
typedef struct Hypervector_TrainSet Hypervector_TrainSet;
typedef struct Hypervector_ClassifySet Hypervector_ClassifySet;

struct Hypervector_Hypervector {
    size_t length;
    uint8_t * elems; // bit array
};

struct Hypervector_Basis {
    size_t n;
    Hypervector_Hypervector * basisVectors;
};

struct Hypervector_TrainSet {
    size_t nLabels;
    size_t length;
    int32_t ** vectors;
};

struct Hypervector_ClassifySet {
    size_t nLabels;
    Hypervector_Hypervector * classVectors;
};

void hypervector_newVector(Hypervector_Hypervector * vector, size_t length) {
    vector -> length = length;
    vector -> elems = (uint8_t*)malloc(length / 8 + 1);
}

void hypervector_deleteVector(Hypervector_Hypervector * vector) {
    free(vector -> elems);
}

void hypervector_newBasis(Hypervector_Basis * basis, size_t length, size_t n) {
    basis -> n = n;
    basis -> basisVectors = (Hypervector_Hypervector*)
        malloc(sizeof(Hypervector_Hypervector) * n);

    Hypervector_Hypervector * vector = basis -> basisVectors;
    size_t i; for (i = 0; i < n; i++) {
        hypervector_newVector(vector, length);

        size_t lengthBytes = length / 8 + 1;
        size_t j; for (j = 0; j < lengthBytes; j++) {
            vector -> elems[j] = rand() & 0xFF;
        }

        vector++;
    }
}

void hypervector_deleteBasis(Hypervector_Basis * basis) {
    size_t i; for (i = 0; i < basis -> n; i++) {
        hypervector_deleteVector(&basis -> basisVectors[i]);
    }
    free(basis -> basisVectors);
}

Hypervector_Hypervector hypervector_encode(uint8_t * input, Hypervector_Basis * basis) {
    
    size_t n = basis -> n;
    size_t length = basis -> basisVectors[0].length;

    int32_t * accBuf = (int32_t*)malloc(sizeof(int32_t*) * length);
    memset(accBuf, 0, sizeof(int32_t*) * length);
    size_t i; for (i = 0; i < n; i++) {

        uint8_t * bitArray = basis -> basisVectors[i].elems;
        size_t j; for (j = 0; j < length; j++) {
            bool elem = (bitArray[j >> 3] >> (j & 0x7)) & 1;
            int32_t inputVal = (int32_t)input[j];

            accBuf[j] += elem ? inputVal : -inputVal;
        }
    }

    Hypervector_Hypervector vector;
    hypervector_newVector(&vector, length);

    size_t j; for (j = 0; j < length; j++) {
        if (accBuf[j] > 0) {
            vector.elems[j >> 3] |= (1 << (j & 0x7));
        }
        else {
            vector.elems[j >> 3] &= ~(1 << (j & 0x7));
        }
    }

    free(accBuf);

    return vector;
}

void hypervector_newTrainSet(Hypervector_TrainSet * trainSet, size_t length, size_t nLabels) {
    trainSet -> nLabels = nLabels;
    trainSet -> length = length;
    trainSet -> vectors = (int32_t**)malloc(sizeof(int32_t*) * nLabels);

    size_t i; for (i = 0; i < nLabels; i++) {
        trainSet -> vectors[i] = (int32_t*)malloc(sizeof(int32_t) * length);
        memset(trainSet -> vectors[i], 0, sizeof(int32_t) * length);
    }
}

void hypervector_deleteTrainSet(Hypervector_TrainSet * trainSet) {
    size_t i; for (i = 0; i < trainSet -> nLabels; i++) {
        free(trainSet -> vectors[i]);
    }
    free(trainSet -> vectors);
}

void hypervector_train(Hypervector_TrainSet * trainSet, Hypervector_Hypervector * vector, 
    size_t label) {
    
    size_t length = vector -> length;

    uint8_t * bitArray = vector -> elems;
    int32_t * trainVector = trainSet -> vectors[label];

    size_t i; for (i = 0; i < length; i++) {
        bool elem = (bitArray[i >> 3] >> (i & 0x7)) & 1;
        trainVector[i] += elem ? 1 : -1;
    }
}

void hypervector_newClassifySet(Hypervector_ClassifySet * classifySet,
                                Hypervector_TrainSet * trainSet) {
    
    size_t nLabels = trainSet -> nLabels;
    size_t length = trainSet -> length;

    classifySet -> nLabels = nLabels;
    classifySet -> classVectors = (Hypervector_Hypervector*)
        malloc(sizeof(Hypervector_Hypervector) * nLabels);

    size_t i; for (i = 0; i < nLabels; i++) {
        Hypervector_Hypervector * vector = &classifySet -> classVectors[i];
        int32_t * trainVector = trainSet -> vectors[i];

        hypervector_newVector(vector, length);
        size_t j; for (j = 0; j < length; j++) {
            if (trainVector[j] > 0) {
                vector -> elems[j >> 3] |= (1 << (j & 0x7));
            }
            else {
                vector -> elems[j >> 3] &= ~(1 << (j & 0x7));
            }
        }
    }
}

void hypervector_deleteClassifySet(Hypervector_ClassifySet * classifySet) {
    size_t i; for (i = 0; i < classifySet -> nLabels; i++) {
        hypervector_deleteVector(&classifySet -> classVectors[i]);
    }
    free(classifySet -> classVectors);
}

size_t hypervector_classify(Hypervector_ClassifySet * classifySet,
    Hypervector_Hypervector * vector) {
    
    size_t bestLabel = (size_t)(-1);
    size_t smallestDistance = (size_t)(-1);

    size_t length = vector -> length;

    size_t label; for (label = 0; label < classifySet -> nLabels; label++) {
        size_t dist = 0;

        uint8_t * bitArray1 = vector -> elems;
        uint8_t * bitArray2 = classifySet -> classVectors[label].elems;

        size_t j; for (j = 0; j < length; j++) {
            uint8_t val1 = (bitArray1[j >> 3] >> (j & 0x7)) & 1;
            uint8_t val2 = (bitArray2[j >> 3] >> (j & 0x7)) & 1;

            if (val1 ^ val2) {
                dist++;
            }
        }

        if (dist < smallestDistance) {
            bestLabel = label;
            smallestDistance = dist;
        }
    }

    return bestLabel;
}


#endif // HYPERVECTOR_C